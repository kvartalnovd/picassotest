# Отчет о выполненной работе
Данный документ содержит описание произведенной на проекте работы по выполнению тестового задания. 
Здесь описаны принятые технологические решения и основания для их принятия. 

**Как итог:** *Все пункты тестового задания выполнены!*

## Содержание
  1. [Содержание](#Содержание)
  2. [Зависимости и технологии проекта](#Зависимости-и-технологии-проекта)
  3. [Исследование данных](#Исследование-данных)
  4. [База Данных](#База-Данных)
  5. [Результат](#Результат)
  6. [Что можно сделать еще?](#Что-можно-сделать-еще)

## Зависимости и технологии проекта
| Технология                                                                        | Цель                       | Причины использования                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | 
|-----------------------------------------------------------------------------------|----------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ` Docker 20.10.10`<br/>` Docker Compose 1.29.2 `                                  | Контейнеризация приложения | Была идея предоставить рабочую модель формата "Batteries Included". <br/>Docker позволил инкапсулировать все необходимые зависимости для используемых технологий в контейнеры. <br/> Docker Compose в свою очередь дал возможность объеденить используемые контейнеры в один кластер. <br/>В совокупности они позволяют создать проект, который корректно работает из коробки на любой машине                                                                                                                                                                                                                                                                                                                          | 
| ` Django 4.0.5 `<br/> `Django REST framework 3.13.1`                              | Web-сервер и API           | Глобальная идея использования Django и DRF состоит в специфики вакансии "ООО Пикассо Софт", а именно требование к "Опыту работы с Django, DRF". <br/>Для данного проекта можно было бы использовать любой другой фреймворк для создания REST API, например FastAPI, Flask, Falcon и т.д.                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ` PostgreSQL 12 `                                                                 | Реляционная БД             | Тех. задание требовало использования реляционной базы данных. Согласно проведенному ["Исследованию данных"](#Исследование-данных), начальный пул данных содержал более 2-х млн. строк, требовалась качественная поддержка единовременной загрузки большого количества данных. Также требовалась нативаная поддержка СУБД выбранным фреймворком — Django официально поддерживает следующие базы данных: PostgreSQL, MariaDB, MySQL, Oracle, SQLite. Любая из них (кроме SQLite, которая по сути является, организованным бинарным файлом, со всеми сопутствующими бинарным файлам проблемами - чтение/запись) подойдет для данного проекта, но к PostgreSQL более склонны сами разработчики Django и ваш покорный слуга |


## Исследование данных
Для более точного составления схемы базы данных было проведено небольшое исследование данных.

Исследование проводились в данном [Python Блокноте в Google Colaboratory](https://colab.research.google.com/drive/1mE52-_llvTzyh6rYMCr5MbWdGcBVql41?usp=sharing).

Для работы в Сolab, полученный в задании пул данных (.csv) был загружен на Google Drive
([Доступ по ссылке](https://drive.google.com/file/d/1ZZpAeZV3vP4gg0lqFeq8J3L5vPJgYj57/view?usp=sharing))


## База Данных

Согласно проведенному ["Исследованию данных"](#Исследование-данных) была выбрана следующая схема базы данных:

![Схема базы данных](/docs/images/db_schema.png "Схема базы данных - drawsql.app")

> Для отображения БД был использован сервис drawsql.app [(Таблица на drawsql.app)](https://drawsql.app/teams/kvartalnovd/diagrams/picasso), 
> который нарисовал схему по файлу [init.sql](/src/docker/images/postgresql/init.sql)


> Для создания моделей Django по legacy DB, изначально использовался иснтрумент django ` python manage.py inspectdb > models.py `.
> После чего модели были поправлены и добавлены в реальные модели django

> Для загрузки данных из csv в sql, использовалась библиотека SQLAlchemy, ее модели были построены вручную. 
> В проекте намеренно не использовалось pandas.dataframe.to_sql из-за большого количества связей в БД

## Результат

Здесь будут описаны результаты по каждому пункту тестового задания:

### Основное:
1. #### Скачайте реестр обращений в полицию San Francisco, ~335mb
2. #### Создайте структуру базы данных (см. раздел [База Данных](#База-Данных))
3. #### Напишите python-скрипт, загружающий данные из csv в базу данных
    Скрипт начинает свою работу [здесь](/src/parserapp/app.py).<br>
    Как запустить скрипт, можно посмотреть [здесь: Запуск парсера CSV](launch_csv_parser.md)<br>
    Скрипт отображает процесс и время загрузки с помощью прогресс бара, результат выполнения скрипта записывается в [логи](/src/storage/logs/parserapp/)    

### Результат:
1. #### SQL для создания схемы базы данных 
    см. файл [init.sql](/src/docker/images/postgresql/init.sql) - он также используется в docker-контейнере для инициализации БД)
2. #### Скрипт для загрузки данных
    Описано выше
3. #### Файл с указанием зависимостей
    Зависимости проекта описаны выше. Зависимости Python лежат [тут: requirements.txt](/src/docker/images/python/requirements.txt)

4. #### LOG-файл с выводом результата работы скрипта
    Описано выше - [Логи лежат тут](/src/storage/logs/parserapp/)

### API:
Разработайте API, будет возвращать инциденты из базы данных. Необходима фильтрация по Report Date 
(параметры date_from и date_to) и возможность ограничивать кол-во результатов по 20 шт. на страницу (параметр page)

Работа API описана в отельном документе: ["Использование API"](using_api.md)

## Что можно сделать еще?
Здесь представлены гипотетические варианты развития проекта. Так как это тестовое задание и проект по своей сути не имеет цели, то в погоне 
за экономией жизненных ресурсов, реализация их не была исполненна (и не будет!).

1. Сделать нормальный nginx с маршрутизацией для PgAdmin, Adminer. Админка и API на отдельных поддоменах
2. Добавить debugger, сделать настройку PyCharm, как результат - debugger из коробки
3. Сделать загрузку .csv файлов на вебсервере, написать фронт и сделать отложенную задачу по обработке, если файл слишком большой

<br/>

> **Главная**: [README.md](/README.md)
> 
> **Далее**: [Быстрый старт: Сборка и запуск программы](quick_start.md)
